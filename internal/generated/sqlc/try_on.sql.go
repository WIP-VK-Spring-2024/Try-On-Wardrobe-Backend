// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: try_on.sql

package sqlc

import (
	"context"

	"try-on/internal/pkg/utils"
)

const createTryOnResult = `-- name: CreateTryOnResult :one
insert into try_on_results(
    clothes_id,
    user_image_id,
    image
) values ($1, $2, $3)
returning id
`

type CreateTryOnResultParams struct {
	ClothesID   []utils.UUID
	UserImageID utils.UUID
	Image       string
}

func (q *Queries) CreateTryOnResult(ctx context.Context, arg CreateTryOnResultParams) (utils.UUID, error) {
	row := q.db.QueryRow(ctx, createTryOnResult, arg.ClothesID, arg.UserImageID, arg.Image)
	var id utils.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteTryOnResult = `-- name: DeleteTryOnResult :exec
delete from try_on_results
where id = $1
`

func (q *Queries) DeleteTryOnResult(ctx context.Context, id utils.UUID) error {
	_, err := q.db.Exec(ctx, deleteTryOnResult, id)
	return err
}

const getTryOnResult = `-- name: GetTryOnResult :one
select try_on_results.id, try_on_results.created_at, try_on_results.updated_at, try_on_results.rating, try_on_results.image, try_on_results.user_image_id, try_on_results.clothes_id
from try_on_results
where id = $1
`

func (q *Queries) GetTryOnResult(ctx context.Context, id utils.UUID) (TryOnResult, error) {
	row := q.db.QueryRow(ctx, getTryOnResult, id)
	var i TryOnResult
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Rating,
		&i.Image,
		&i.UserImageID,
		&i.ClothesID,
	)
	return i, err
}

const getTryOnResultsByClothes = `-- name: GetTryOnResultsByClothes :many
select id, created_at, updated_at, rating, image, user_image_id, clothes_id
from try_on_results
where $1::uuid = any(clothes_id)
`

func (q *Queries) GetTryOnResultsByClothes(ctx context.Context, dollar_1 utils.UUID) ([]TryOnResult, error) {
	rows, err := q.db.Query(ctx, getTryOnResultsByClothes, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TryOnResult
	for rows.Next() {
		var i TryOnResult
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Rating,
			&i.Image,
			&i.UserImageID,
			&i.ClothesID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTryOnResultsByUser = `-- name: GetTryOnResultsByUser :many
select try_on_results.id, try_on_results.created_at, try_on_results.updated_at, try_on_results.rating, try_on_results.image, try_on_results.user_image_id, try_on_results.clothes_id
from try_on_results
join user_images u on u.id = try_on_results.user_image_id
where u.user_id = $1
`

func (q *Queries) GetTryOnResultsByUser(ctx context.Context, userID utils.UUID) ([]TryOnResult, error) {
	rows, err := q.db.Query(ctx, getTryOnResultsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TryOnResult
	for rows.Next() {
		var i TryOnResult
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Rating,
			&i.Image,
			&i.UserImageID,
			&i.ClothesID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rateTryOnResult = `-- name: RateTryOnResult :exec
update try_on_results 
set rating = $2::int,
    updated_at = now()
where id = $1
`

func (q *Queries) RateTryOnResult(ctx context.Context, iD utils.UUID, rating int32) error {
	_, err := q.db.Exec(ctx, rateTryOnResult, iD, rating)
	return err
}
