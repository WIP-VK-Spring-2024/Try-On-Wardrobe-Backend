// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: feed.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"try-on/internal/pkg/domain"
	"try-on/internal/pkg/utils"
)

const getLikedPosts = `-- name: GetLikedPosts :many
select
    posts.id,
    posts.created_at,
    posts.updated_at,
    posts.outfit_id,
    outfits.user_id,
    outfits.image as outfit_image,
    users.avatar as user_image,
    users.name as user_name,
    posts.rating,
    case when subs.created_at is not null then true
         else false end is_subbed,
    post_ratings.value as user_rating,
    coalesce(try_on_results.image, '') as try_on_image,
    coalesce(try_on_results.id, uuid_nil()) as try_on_id
from posts
join outfits on outfits.id = posts.outfit_id
join users on users.id = outfits.user_id
join post_ratings on post_ratings.user_id = $1
        and post_ratings.post_id = posts.id
left join subs on subs.subscriber_id = $1 and subs.user_id = outfits.user_id
left join try_on_results on try_on_results.id = outfits.try_on_result_id
where posts.created_at < $3::timestamp
    and post_ratings.value = 1
order by posts.created_at desc
limit $2
`

type GetLikedPostsParams struct {
	UserID utils.UUID
	Limit  int32
	Since  pgtype.Timestamp
}

type GetLikedPostsRow struct {
	ID          utils.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	OutfitID    utils.UUID
	UserID      utils.UUID
	OutfitImage pgtype.Text
	UserImage   string
	UserName    string
	Rating      int32
	IsSubbed    bool
	UserRating  int32
	TryOnImage  string
	TryOnID     utils.UUID
}

func (q *Queries) GetLikedPosts(ctx context.Context, arg GetLikedPostsParams) ([]GetLikedPostsRow, error) {
	rows, err := q.db.Query(ctx, getLikedPosts, arg.UserID, arg.Limit, arg.Since)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLikedPostsRow
	for rows.Next() {
		var i GetLikedPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OutfitID,
			&i.UserID,
			&i.OutfitImage,
			&i.UserImage,
			&i.UserName,
			&i.Rating,
			&i.IsSubbed,
			&i.UserRating,
			&i.TryOnImage,
			&i.TryOnID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPosts = `-- name: GetPosts :many
select
    posts.id,
    posts.created_at,
    posts.updated_at,
    posts.outfit_id,
    outfits.user_id,
    outfits.image as outfit_image,
    users.avatar as user_image,
    users.name as user_name,
    posts.rating,
    case when subs.created_at is not null then true
         else false end is_subbed,
    coalesce(post_ratings.value, 0) as user_rating,
    coalesce(try_on_results.image, '') as try_on_image,
    coalesce(try_on_results.id, uuid_nil()) as try_on_id
from posts
join outfits on outfits.id = posts.outfit_id
join users on users.id = outfits.user_id
left join post_ratings on post_ratings.user_id = $1
        and post_ratings.post_id = posts.id
left join subs on subs.subscriber_id = $1 and subs.user_id = outfits.user_id
left join try_on_results on try_on_results.id = outfits.try_on_result_id
where posts.created_at < $3::timestamp
    and users.gender = any($4::gender[])
order by posts.created_at desc
limit $2
`

type GetPostsParams struct {
	UserID  utils.UUID
	Limit   int32
	Since   pgtype.Timestamp
	Genders []domain.Gender
}

type GetPostsRow struct {
	ID          utils.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	OutfitID    utils.UUID
	UserID      utils.UUID
	OutfitImage pgtype.Text
	UserImage   string
	UserName    string
	Rating      int32
	IsSubbed    bool
	UserRating  int32
	TryOnImage  string
	TryOnID     utils.UUID
}

func (q *Queries) GetPosts(ctx context.Context, arg GetPostsParams) ([]GetPostsRow, error) {
	rows, err := q.db.Query(ctx, getPosts,
		arg.UserID,
		arg.Limit,
		arg.Since,
		arg.Genders,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsRow
	for rows.Next() {
		var i GetPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OutfitID,
			&i.UserID,
			&i.OutfitImage,
			&i.UserImage,
			&i.UserName,
			&i.Rating,
			&i.IsSubbed,
			&i.UserRating,
			&i.TryOnImage,
			&i.TryOnID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByIds = `-- name: GetPostsByIds :many
select
    posts.id,
    posts.created_at,
    posts.updated_at,
    posts.outfit_id,
    outfits.user_id,
    outfits.image as outfit_image,
    users.avatar as user_image,
    users.name as user_name,
    posts.rating,
    case when subs.created_at is not null then true
         else false end is_subbed,
    coalesce(post_ratings.value, 0) as user_rating,
    coalesce(try_on_results.image, '') as try_on_image,
    coalesce(try_on_results.id, uuid_nil()) as try_on_id
from posts
join outfits on outfits.id = posts.outfit_id
join users on users.id = outfits.user_id
left join post_ratings on post_ratings.user_id = $1
        and post_ratings.post_id = posts.id
left join subs on subs.subscriber_id = $1 and subs.user_id = outfits.user_id
left join try_on_results on try_on_results.id = outfits.try_on_result_id
where posts.outfit_id = any($2::uuid[])
order by posts.created_at desc
`

type GetPostsByIdsRow struct {
	ID          utils.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	OutfitID    utils.UUID
	UserID      utils.UUID
	OutfitImage pgtype.Text
	UserImage   string
	UserName    string
	Rating      int32
	IsSubbed    bool
	UserRating  int32
	TryOnImage  string
	TryOnID     utils.UUID
}

func (q *Queries) GetPostsByIds(ctx context.Context, userID utils.UUID, outfitIds []utils.UUID) ([]GetPostsByIdsRow, error) {
	rows, err := q.db.Query(ctx, getPostsByIds, userID, outfitIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsByIdsRow
	for rows.Next() {
		var i GetPostsByIdsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OutfitID,
			&i.UserID,
			&i.OutfitImage,
			&i.UserImage,
			&i.UserName,
			&i.Rating,
			&i.IsSubbed,
			&i.UserRating,
			&i.TryOnImage,
			&i.TryOnID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsByUser = `-- name: GetPostsByUser :many
select
    posts.id,
    posts.created_at,
    posts.updated_at,
    posts.outfit_id,
    outfits.user_id,
    outfits.image as outfit_image,
    users.avatar as user_image,
    users.name as user_name,
    posts.rating,
    case when subs.created_at is not null then true
         else false end is_subbed,
    coalesce(post_ratings.value, 0) as user_rating,
    coalesce(try_on_results.image, '') as try_on_image,
    coalesce(try_on_results.id, uuid_nil()) as try_on_id
from posts
join outfits on outfits.id = posts.outfit_id
join users on users.id = outfits.user_id
left join post_ratings on post_ratings.user_id = $1
        and post_ratings.post_id = posts.id
left join subs on subs.subscriber_id = $1 and subs.user_id = outfits.user_id
left join try_on_results on try_on_results.id = outfits.try_on_result_id
where posts.created_at < $3::timestamp
      and outfits.user_id = $4
order by posts.created_at desc
limit $2
`

type GetPostsByUserParams struct {
	UserID   utils.UUID
	Limit    int32
	Since    pgtype.Timestamp
	AuthorID utils.UUID
}

type GetPostsByUserRow struct {
	ID          utils.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	OutfitID    utils.UUID
	UserID      utils.UUID
	OutfitImage pgtype.Text
	UserImage   string
	UserName    string
	Rating      int32
	IsSubbed    bool
	UserRating  int32
	TryOnImage  string
	TryOnID     utils.UUID
}

func (q *Queries) GetPostsByUser(ctx context.Context, arg GetPostsByUserParams) ([]GetPostsByUserRow, error) {
	rows, err := q.db.Query(ctx, getPostsByUser,
		arg.UserID,
		arg.Limit,
		arg.Since,
		arg.AuthorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPostsByUserRow
	for rows.Next() {
		var i GetPostsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OutfitID,
			&i.UserID,
			&i.OutfitImage,
			&i.UserImage,
			&i.UserName,
			&i.Rating,
			&i.IsSubbed,
			&i.UserRating,
			&i.TryOnImage,
			&i.TryOnID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionPosts = `-- name: GetSubscriptionPosts :many
select
    posts.id,
    posts.created_at,
    posts.updated_at,
    posts.outfit_id,
    outfits.user_id,
    outfits.image as outfit_image,
    users.avatar as user_image,
    users.name as user_name,
    posts.rating,
    true as is_subbed,
    coalesce(post_ratings.value, 0) as user_rating,
    coalesce(try_on_results.image, '') as try_on_image,
    coalesce(try_on_results.id, uuid_nil()) as try_on_id
from posts
join outfits on outfits.id = posts.outfit_id
join users on users.id = outfits.user_id
join subs on subs.user_id = users.id and subs.subscriber_id = $1
left join post_ratings on post_ratings.user_id = $1
        and post_ratings.post_id = posts.id
left join try_on_results on try_on_results.id = outfits.try_on_result_id
where posts.created_at < $3::timestamp
order by posts.created_at
limit $2
`

type GetSubscriptionPostsParams struct {
	SubscriberID utils.UUID
	Limit        int32
	Since        pgtype.Timestamp
}

type GetSubscriptionPostsRow struct {
	ID          utils.UUID
	CreatedAt   pgtype.Timestamp
	UpdatedAt   pgtype.Timestamp
	OutfitID    utils.UUID
	UserID      utils.UUID
	OutfitImage pgtype.Text
	UserImage   string
	UserName    string
	Rating      int32
	IsSubbed    bool
	UserRating  int32
	TryOnImage  string
	TryOnID     utils.UUID
}

func (q *Queries) GetSubscriptionPosts(ctx context.Context, arg GetSubscriptionPostsParams) ([]GetSubscriptionPostsRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionPosts, arg.SubscriberID, arg.Limit, arg.Since)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubscriptionPostsRow
	for rows.Next() {
		var i GetSubscriptionPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OutfitID,
			&i.UserID,
			&i.OutfitImage,
			&i.UserImage,
			&i.UserName,
			&i.Rating,
			&i.IsSubbed,
			&i.UserRating,
			&i.TryOnImage,
			&i.TryOnID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ratePost = `-- name: RatePost :exec
insert into post_ratings(post_id, user_id, value)
    values($1, $2, $3)
    on conflict (post_id, user_id) do update
    set value = excluded.value
`

type RatePostParams struct {
	PostID utils.UUID
	UserID utils.UUID
	Value  int32
}

func (q *Queries) RatePost(ctx context.Context, arg RatePostParams) error {
	_, err := q.db.Exec(ctx, ratePost, arg.PostID, arg.UserID, arg.Value)
	return err
}

const subscribe = `-- name: Subscribe :exec
insert into subs(subscriber_id, user_id)
    values($1, $2)
`

func (q *Queries) Subscribe(ctx context.Context, subscriberID utils.UUID, userID utils.UUID) error {
	_, err := q.db.Exec(ctx, subscribe, subscriberID, userID)
	return err
}

const unsubscribe = `-- name: Unsubscribe :exec
delete from subs
where subscriber_id = $1 and user_id = $2
`

func (q *Queries) Unsubscribe(ctx context.Context, subscriberID utils.UUID, userID utils.UUID) error {
	_, err := q.db.Exec(ctx, unsubscribe, subscriberID, userID)
	return err
}
