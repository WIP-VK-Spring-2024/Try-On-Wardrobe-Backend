// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createClothes = `-- name: CreateClothes :one
insert into clothes(
    name,
    user_id,
    type_id,
    subtype_id,
    image,
    color
)
values ($1, $2, $3, $4, $5, $6)
returning id
`

type CreateClothesParams struct {
	Name      string
	UserID    uuid.UUID
	TypeID    uuid.UUID
	SubtypeID uuid.UUID
	Image     pgtype.Text
	Color     pgtype.Text
}

func (q *Queries) CreateClothes(ctx context.Context, arg CreateClothesParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createClothes,
		arg.Name,
		arg.UserID,
		arg.TypeID,
		arg.SubtypeID,
		arg.Image,
		arg.Color,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createClothesTagLinks = `-- name: CreateClothesTagLinks :exec
insert into clothes_tags (clothes_id, tag_id)
    select $1, tag_id
    from tags where name = any($2::text[])
`

type CreateClothesTagLinksParams struct {
	ClothesID uuid.UUID
	Tags      []string
}

func (q *Queries) CreateClothesTagLinks(ctx context.Context, arg CreateClothesTagLinksParams) error {
	_, err := q.db.Exec(ctx, createClothesTagLinks, arg.ClothesID, arg.Tags)
	return err
}

const createStyle = `-- name: CreateStyle :one
insert into styles(name, created_at)
values ($1, now())
on conflict(name) do update
set name = excluded.name
returning id
`

func (q *Queries) CreateStyle(ctx context.Context, name string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createStyle, name)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const createTags = `-- name: CreateTags :exec
insert into tags (name) values (  
  unnest($1::varchar[])
) on conflict do nothing
`

func (q *Queries) CreateTags(ctx context.Context, names []string) error {
	_, err := q.db.Exec(ctx, createTags, names)
	return err
}

const deleteClothes = `-- name: DeleteClothes :exec
delete from clothes
where id = $1
`

func (q *Queries) DeleteClothes(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteClothes, id)
	return err
}

const getClothesById = `-- name: GetClothesById :one
select
    clothes.id, clothes.created_at, clothes.updated_at, clothes.name, clothes.note, clothes.image, clothes.user_id, clothes.style_id, clothes.type_id, clothes.subtype_id, clothes.color, clothes.seasons,
    types.name as type,
    subtypes.name as subtype,
    styles.name as style,
    array_agg(coalesce(tags.name, ''))::text[] as tags
from clothes
join types on types.id = clothes.type_id
join subtypes on subtypes.id = clothes.subtype_id
left join styles on styles.id = clothes.style_id
left join clothes_tags on clothes.id = clothes_tags.clothes_id
left join tags on clothes_tags.tag_id = tags.id
where clothes.id = $1
group by
    clothes.id,
    clothes.name,
    clothes.note,
    clothes.type_id,
    clothes.subtype_id,
    clothes.style_id,
    clothes.color,
    clothes.seasons,
    clothes.created_at,
    clothes.updated_at,
    clothes.image,
    type,
    subtype,
    style
`

type GetClothesByIdRow struct {
	ID        uuid.UUID
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Name      string
	Note      pgtype.Text
	Image     pgtype.Text
	UserID    uuid.UUID
	StyleID   pgtype.UUID
	TypeID    uuid.UUID
	SubtypeID uuid.UUID
	Color     pgtype.Text
	Seasons   []Season
	Type      string
	Subtype   string
	Style     pgtype.Text
	Tags      []string
}

func (q *Queries) GetClothesById(ctx context.Context, id uuid.UUID) (GetClothesByIdRow, error) {
	row := q.db.QueryRow(ctx, getClothesById, id)
	var i GetClothesByIdRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Note,
		&i.Image,
		&i.UserID,
		&i.StyleID,
		&i.TypeID,
		&i.SubtypeID,
		&i.Color,
		&i.Seasons,
		&i.Type,
		&i.Subtype,
		&i.Style,
		&i.Tags,
	)
	return i, err
}

const getClothesByUser = `-- name: GetClothesByUser :many
select
    clothes.id, clothes.created_at, clothes.updated_at, clothes.name, clothes.note, clothes.image, clothes.user_id, clothes.style_id, clothes.type_id, clothes.subtype_id, clothes.color, clothes.seasons,
    types.name as type,
    subtypes.name as subtype,
    styles.name as style,
    array_agg(coalesce(tags.name, ''))::text[] as tags
from clothes
join types on types.id = clothes.type_id
join subtypes on subtypes.id = clothes.subtype_id
left join styles on styles.id = clothes.style_id
left join clothes_tags on clothes.id = clothes_tags.clothes_id
left join tags on clothes_tags.tag_id = tags.id
where clothes.user_id = $1
group by
    clothes.id,
    clothes.name,
    clothes.note,
    clothes.type_id,
    clothes.subtype_id,
    clothes.style_id,
    clothes.color,
    clothes.seasons,
    clothes.created_at,
    clothes.updated_at,
    clothes.image,
    type,
    subtype,
    style
`

type GetClothesByUserRow struct {
	ID        uuid.UUID
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Name      string
	Note      pgtype.Text
	Image     pgtype.Text
	UserID    uuid.UUID
	StyleID   pgtype.UUID
	TypeID    uuid.UUID
	SubtypeID uuid.UUID
	Color     pgtype.Text
	Seasons   []Season
	Type      string
	Subtype   string
	Style     pgtype.Text
	Tags      []string
}

func (q *Queries) GetClothesByUser(ctx context.Context, userID uuid.UUID) ([]GetClothesByUserRow, error) {
	rows, err := q.db.Query(ctx, getClothesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClothesByUserRow
	for rows.Next() {
		var i GetClothesByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Note,
			&i.Image,
			&i.UserID,
			&i.StyleID,
			&i.TypeID,
			&i.SubtypeID,
			&i.Color,
			&i.Seasons,
			&i.Type,
			&i.Subtype,
			&i.Style,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubtypes = `-- name: GetSubtypes :many
select id, created_at, updated_at, name, type_id from subtypes
`

func (q *Queries) GetSubtypes(ctx context.Context) ([]Subtype, error) {
	rows, err := q.db.Query(ctx, getSubtypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Subtype
	for rows.Next() {
		var i Subtype
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.TypeID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTypes = `-- name: GetTypes :many
select id, created_at, updated_at, name from types
`

func (q *Queries) GetTypes(ctx context.Context) ([]Type, error) {
	rows, err := q.db.Query(ctx, getTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Type
	for rows.Next() {
		var i Type
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClothes = `-- name: UpdateClothes :exec
update clothes
set name = coalesce($2, name),
    note = coalesce($3, note),
    type_id = coalesce($4, type_id),
    subtype_id = coalesce($5, subtype_id),
    style_id = coalesce($6, style_id),
    color = coalesce($7, color),
    seasons = coalesce($8, seasons),
    updated_at = now()
where id = $1
`

type UpdateClothesParams struct {
	ID        uuid.UUID
	Name      string
	Note      pgtype.Text
	TypeID    uuid.UUID
	SubtypeID uuid.UUID
	StyleID   pgtype.UUID
	Color     pgtype.Text
	Seasons   []Season
}

func (q *Queries) UpdateClothes(ctx context.Context, arg UpdateClothesParams) error {
	_, err := q.db.Exec(ctx, updateClothes,
		arg.ID,
		arg.Name,
		arg.Note,
		arg.TypeID,
		arg.SubtypeID,
		arg.StyleID,
		arg.Color,
		arg.Seasons,
	)
	return err
}
