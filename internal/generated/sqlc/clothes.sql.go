// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: clothes.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"try-on/internal/pkg/utils"
)

const createClothes = `-- name: CreateClothes :one
insert into clothes(
    name,
    user_id,
    type_id,
    subtype_id,
    color
)
values ($1, $2, $3, $4, $5)
returning id
`

type CreateClothesParams struct {
	Name      string
	UserID    utils.UUID
	TypeID    utils.UUID
	SubtypeID utils.UUID
	Color     pgtype.Text
}

func (q *Queries) CreateClothes(ctx context.Context, arg CreateClothesParams) (utils.UUID, error) {
	row := q.db.QueryRow(ctx, createClothes,
		arg.Name,
		arg.UserID,
		arg.TypeID,
		arg.SubtypeID,
		arg.Color,
	)
	var id utils.UUID
	err := row.Scan(&id)
	return id, err
}

const createClothesTagLinks = `-- name: CreateClothesTagLinks :exec
insert into clothes_tags (clothes_id, tag_id)
    select $1, id
    from tags where name = any($2::text[])
`

func (q *Queries) CreateClothesTagLinks(ctx context.Context, clothesID utils.UUID, tags []string) error {
	_, err := q.db.Exec(ctx, createClothesTagLinks, clothesID, tags)
	return err
}

const createTags = `-- name: CreateTags :exec
insert into tags (name) values (  
  unnest($1::varchar[])
) on conflict do nothing
`

func (q *Queries) CreateTags(ctx context.Context, names []string) error {
	_, err := q.db.Exec(ctx, createTags, names)
	return err
}

const deleteClothes = `-- name: DeleteClothes :exec
delete from clothes
where id = $1
`

func (q *Queries) DeleteClothes(ctx context.Context, id utils.UUID) error {
	_, err := q.db.Exec(ctx, deleteClothes, id)
	return err
}

const getClothesById = `-- name: GetClothesById :one
select
    clothes.id, clothes.created_at, clothes.updated_at, clothes.name, clothes.note, clothes.user_id, clothes.style_id, clothes.type_id, clothes.subtype_id, clothes.color, clothes.seasons,
    types.name as type,
    subtypes.name as subtype,
    styles.name as style,
    array_agg(coalesce(tags.name, ''))::text[] as tags
from clothes
join types on types.id = clothes.type_id
join subtypes on subtypes.id = clothes.subtype_id
left join styles on styles.id = clothes.style_id
left join clothes_tags on clothes.id = clothes_tags.clothes_id
left join tags on clothes_tags.tag_id = tags.id
where clothes.id = $1
group by
    clothes.id,
    clothes.name,
    clothes.note,
    clothes.type_id,
    clothes.subtype_id,
    clothes.style_id,
    clothes.color,
    clothes.seasons,
    clothes.created_at,
    clothes.updated_at,
    type,
    subtype,
    style
`

type GetClothesByIdRow struct {
	ID        utils.UUID
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Name      string
	Note      pgtype.Text
	UserID    utils.UUID
	StyleID   utils.UUID
	TypeID    utils.UUID
	SubtypeID utils.UUID
	Color     pgtype.Text
	Seasons   []Season
	Type      string
	Subtype   string
	Style     pgtype.Text
	Tags      []string
}

func (q *Queries) GetClothesById(ctx context.Context, id utils.UUID) (GetClothesByIdRow, error) {
	row := q.db.QueryRow(ctx, getClothesById, id)
	var i GetClothesByIdRow
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Note,
		&i.UserID,
		&i.StyleID,
		&i.TypeID,
		&i.SubtypeID,
		&i.Color,
		&i.Seasons,
		&i.Type,
		&i.Subtype,
		&i.Style,
		&i.Tags,
	)
	return i, err
}

const getClothesByUser = `-- name: GetClothesByUser :many
select
    clothes.id, clothes.created_at, clothes.updated_at, clothes.name, clothes.note, clothes.user_id, clothes.style_id, clothes.type_id, clothes.subtype_id, clothes.color, clothes.seasons,
    types.name as type,
    subtypes.name as subtype,
    styles.name as style,
    array_agg(coalesce(tags.name, ''))::text[] as tags
from clothes
join types on types.id = clothes.type_id
join subtypes on subtypes.id = clothes.subtype_id
left join styles on styles.id = clothes.style_id
left join clothes_tags on clothes.id = clothes_tags.clothes_id
left join tags on clothes_tags.tag_id = tags.id
where clothes.user_id = $1
group by
    clothes.id,
    clothes.name,
    clothes.note,
    clothes.type_id,
    clothes.subtype_id,
    clothes.style_id,
    clothes.color,
    clothes.seasons,
    clothes.created_at,
    clothes.updated_at,
    type,
    subtype,
    style
`

type GetClothesByUserRow struct {
	ID        utils.UUID
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
	Name      string
	Note      pgtype.Text
	UserID    utils.UUID
	StyleID   utils.UUID
	TypeID    utils.UUID
	SubtypeID utils.UUID
	Color     pgtype.Text
	Seasons   []Season
	Type      string
	Subtype   string
	Style     pgtype.Text
	Tags      []string
}

func (q *Queries) GetClothesByUser(ctx context.Context, userID utils.UUID) ([]GetClothesByUserRow, error) {
	rows, err := q.db.Query(ctx, getClothesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetClothesByUserRow
	for rows.Next() {
		var i GetClothesByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Note,
			&i.UserID,
			&i.StyleID,
			&i.TypeID,
			&i.SubtypeID,
			&i.Color,
			&i.Seasons,
			&i.Type,
			&i.Subtype,
			&i.Style,
			&i.Tags,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClothes = `-- name: UpdateClothes :exec
update clothes
set name = coalesce($2, name),
    note = coalesce($3, note),
    type_id = coalesce($4, type_id),
    subtype_id = coalesce($5, subtype_id),
    style_id = coalesce($6, style_id),
    color = coalesce($7, color),
    seasons = coalesce($8, seasons),
    updated_at = now()
where id = $1
`

type UpdateClothesParams struct {
	ID        utils.UUID
	Name      string
	Note      pgtype.Text
	TypeID    utils.UUID
	SubtypeID utils.UUID
	StyleID   utils.UUID
	Color     pgtype.Text
	Seasons   []Season
}

func (q *Queries) UpdateClothes(ctx context.Context, arg UpdateClothesParams) error {
	_, err := q.db.Exec(ctx, updateClothes,
		arg.ID,
		arg.Name,
		arg.Note,
		arg.TypeID,
		arg.SubtypeID,
		arg.StyleID,
		arg.Color,
		arg.Seasons,
	)
	return err
}
